<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: helpers.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: helpers.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const {
  identity,
  isDeepVal,
  isFunction,
  isPrimative,
  isRegEx
} = require("./utils");

// NOTE:  All return functions must have names becuase
//        they are used for the babel plugin

/**
 * &lt;h3>Between bounds&lt;/h3>
 * Return a function that checks to see if it's input is between two numbers not including the numbers.
 *
 * @param {number} a The lower number
 * @param {number} b The higher number
 * @return {function} A function of the form number => boolean
 */
const btw = () =>
  function btw(a, b) {
    return function btwFn(n) {
      const [min, max] = a &lt; b ? [a, b] : [b, a];
      return n > min &amp;&amp; n &lt; max;
    };
  };

/**
 * &lt;h3>Between bounds or equal to&lt;/h3>
 * Return a function that checks to see if it's input is between two numbers including the numbers.
 *
 * @param {number} a The lower number
 * @param {number} b The higher number
 * @return {function} A function of the form number => boolean
 */
const btwe = () =>
  function btwe(a, b) {
    return function btweFn(n) {
      const [min, max] = a &lt; b ? [a, b] : [b, a];
      return n >= min &amp;&amp; n &lt;= max;
    };
  };

/**
 * &lt;h3>Less than&lt;/h3>
 * Return a function that checks to see if it's input is less than the given number.
 *
 * @param {number} a The number to check against.
 * @return {function} A function of the form number => boolean
 */
const lt = () =>
  function lt(a) {
    return function ltFn(n) {
      return n &lt; a;
    };
  };

/**
 * &lt;h3>Less than or equal to&lt;/h3>
 * Return a function that checks to see if it's input is less than or equal to the given number.
 *
 * @param {number} a The number to check against.
 * @return {function} A function of the form number => boolean
 */
const lte = () =>
  function lte(a) {
    return function lteFn(n) {
      return n &lt;= a;
    };
  };

/**
 * &lt;h3>Greater than&lt;/h3>
 * Return a function that checks to see if it's input is greater than the given number.
 *
 * @param {number} a The number to check against.
 * @return {function} A function of the form number => boolean
 */
const gt = () =>
  function gt(a) {
    return function gtFn(n) {
      return n > a;
    };
  };
/**
 * &lt;h3>Greater than or equal to&lt;/h3>
 * Return a function that checks to see if it's input is greater than or equal to the given number.
 *
 * @param {number} a The number to check against.
 * @return {function} A function of the form number => boolean
 */
const gte = () =>
  function gte(a) {
    return function gteFn(n) {
      return n >= a;
    };
  };

/**
 * &lt;h3>Array match&lt;/h3>
 * Return a function that checks to see if an array contains either any of the values listed or if any of the predicate functions provided return true when run over all items in the array.
 * Eg,
 * &lt;pre>&lt;code>
 * // Helper functions
 * const isNumeric = a => typeof a === 'number';
 * const isString = a => typeof a === 'string';
 *
 * arrArgMatch(isNumeric, isNumeric, isNumeric)([1,2,3]); // true
 * arrArgMatch(isNumeric, isNumeric, isNumeric, '...')([1,2,3]); // true
 * arrArgMatch(isString, isNumeric, isNumeric, '...')([1,2,3]); // false
 * arrArgMatch(isString, isNumeric, isNumeric, '...')(['1',2,3]); // true
 * arrArgMatch(isNumeric, isNumeric, isNumeric, '...')([1,2,3,4]); // true
 * arrArgMatch(1, 2)([1,3]); // false
 * &lt;/code>&lt;/pre>
 *
 * @param {...function|*} tests Either values, `['...', predicate]` or predicate functions used to test the contents of the array.
 * @return {function} A function of the form &lt;code>{array => boolean}&lt;/code>
 */
const arrArgMatch = ctx =>
  function arrArgMatch(...tests) {
    function matchFn(arr) {
      const hasWildcard = tests.slice(-1)[0] === "...";
      let matches = hasWildcard || arr.length === tests.length;
      for (let i = 0; i &lt; tests.length; i++) {
        const testVal = tests[i];
        const predicate = testVal === "..." ? wildcard(ctx) : val(ctx)(testVal);
        const pass = predicate(arr[i]);
        matches = matches &amp;&amp; pass;
      }
      return matches;
    }
    return matchFn;
  };

/**
 * &lt;h3>Array type match&lt;/h3>
 * Return a function that checks to see if an array contains only the values listed or if the predicate function provided returns true when run over all items in the array.
 * Eg,
 * &lt;pre>&lt;code>
 * // Helper functions
 * const isNumeric = a => typeof a === 'number';
 * const isString = a => typeof a === 'string';
 *
 * arrTypeMatch(isNumeric)([1,2,3]); // true
 * arrTypeMatch(isNumeric)([1,2,'3']); // false
 * arrTypeMatch(isNumeric)([]); // true
 * &lt;/code>&lt;/pre>
 *
 * @param {function|*} test predicate function used to test the contents of the array.
 * @return {function} A function of the form &lt;code>{array => boolean}&lt;/code>
 */
const arrTypeMatch = ctx =>
  function arrTypeMatch(test) {
    const predicate = val(ctx)(test);
    function matchFn(arr) {
      if (!Array.isArray(arr)) return false;

      let matches = true;
      for (let i = 0; i &lt; arr.length; i++) {
        matches = matches &amp;&amp; predicate(arr[i]);
      }
      return matches;
    }
    return matchFn;
  };

/**
 * &lt;h3>Array holds&lt;/h3>
 * Return a function that checks to see if an array contains either any of the values listed or if any of the predicate functions provided return true when run over all items in the array.
 * Eg,
 * &lt;pre>&lt;code>
 * holds(a => a > 3, 2)([1,2,3]); // true
 * holds(1, 2)([1,3]); // false
 * &lt;/code>&lt;/pre>
 *
 * @param {...function|*} args Either values or predicate functions used to test the contents of the array.
 * @return {function} A function of the form &lt;code>{array => boolean}&lt;/code>
 */
const holds = ctx =>
  function holds(...args) {
    return function holdsFn(n) {
      let i, j;
      let fns = [];
      let success = [];

      // prepare args as an array of predicate fns and an array to keep track of success
      for (i = 0; i &lt; args.length; i++) {
        const arg = args[i];
        fns.push(val(ctx)(arg));
        success.push(false);
      }

      // loop through array only once
      for (i = 0; i &lt; n.length; i++) {
        const item = n[i];
        for (j = 0; j &lt; fns.length; j++) {
          if (!success[j]) {
            const fn = fns[j];
            success[j] = success[j] || fn(item);
          }
        }
      }

      return success.reduce((a, b) => a &amp;&amp; b);
    };
  };

/**
 * &lt;h3>Logical OR&lt;/h3>
 * Combine predicates to form a new predicate that ORs the result of the input predicates.
 *
 * @param {function} left The first predicate
 * @param {function} right The second predicate
 * @return {function} A function of the form &lt;code>{any => boolean}&lt;/code>
 */
const or = ctx =>
  function or(left, right) {
    return function orFn(a) {
      const valCtx = val(ctx);
      return valCtx(left)(a) || valCtx(right)(a);
    };
  };

/**
 * &lt;h3>Logical AND&lt;/h3>
 * Combine predicates to form a new predicate that ANDs the result of the input predicates.
 *
 * @param {function} left The first predicate
 * @param {function} right The second predicate
 * @return {function} A function of the form &lt;code>{any => boolean}&lt;/code>
 */
const and = ctx =>
  function and(left, right) {
    return function andFn(a) {
      const valCtx = val(ctx);
      return valCtx(left)(a) &amp;&amp; valCtx(right)(a);
    };
  };

/**
 * &lt;h3>Logical NOT&lt;/h3>
 * Takes an input predicate to form a new predicate that NOTs the result of the input predicate.
 *
 * @param {function} input The input predicate
 * @return {function} A function of the form &lt;code>{any => boolean}&lt;/code>
 */
const not = ctx =>
  function not(input) {
    return function notFn(a) {
      return !val(ctx)(input)(a);
    };
  };

const extant = () =>
  function extant(a) {
    return a !== null &amp;&amp; a !== undefined;
  };

/**
 * &lt;h3>Truthy&lt;/h3>
 * A predicate that takes an input value and returns whether or not the value is truthy
 *
 * @param {function} input The input value
 * @return {boolean} Boolean value indicating if the input is truthy
 */
const truthy = () =>
  function truthy(a) {
    return !!a;
  };

/**
 * &lt;h3>Falsey&lt;/h3>
 * A predicate that takes an input value and returns whether or not the value is falsey
 *
 * @param {function} input The input value
 * @return {boolean} Boolean value indicating if the input is falsey
 */
const falsey = () =>
  function falsey(a) {
    return !a;
  };

const obj = ctx =>
  function obj(...entriesWithRest) {
    return function objFn(a) {
      const isExtant = extant(ctx);
      let hasRest = false;
      let entriesMatch = true;
      let entryCount = 0;

      // For loop is faster
      for (let i = 0; i &lt; entriesWithRest.length; i++) {
        const entry = entriesWithRest[i];

        // Ignore rest and note we have one
        if (entry === "...") {
          hasRest = hasRest || true;
          continue;
        }

        // Extract key and predicate from the entry and run the predicate against the value
        const [key, predicate] = Array.isArray(entry)
          ? entry
          : [entry, isExtant];
        entriesMatch = entriesMatch &amp;&amp; isExtant(a) &amp;&amp; predicate(a[key]);

        // We just logged an entry track it
        entryCount++;
      }

      // If there was a rest arg we don't need to check length
      if (hasRest) return entriesMatch;

      // Check entry length
      return entriesMatch &amp;&amp; Object.keys(a).length === entryCount;
    };
  };

/**
 * &lt;h3>Is strict equal to value&lt;/h3>
 * Takes an input value to form a predicate that checks if the input strictly equals by reference the value.
 *
 * @param {function|*} value The input value if already a fuction it will be returned
 * @return {function} A function of the form &lt;code>{any => boolean}&lt;/code>
 */
const val = () => value =>
  typeof value === "function"
    ? value
    : function isVal(a) {
        return a === value;
      };

/**
 * &lt;h3>Is deep equal to value&lt;/h3>
 * Takes an input value to form a predicate that checks if the input deeply equals the value.
 *
 * @param {function} value The input value
 * @return {function} A function of the form &lt;code>{any => boolean}&lt;/code>
 */
const deep = () =>
  function deep(value) {
    const st = JSON.stringify(value);
    return a => st === JSON.stringify(a);
  };

/**
 * &lt;h3>Regular Expression predicate&lt;/h3>
 * Forms a predicate from a given regular expression
 *
 * @param {RegExp} rx The input value
 * @return {function} A function of the form &lt;code>{any => boolean}&lt;/code>
 */
const regx = ctx =>
  function regx(rx) {
    const rgx = typeof rx === "function" ? rx(ctx) : rx;
    return rgx.test.bind(rgx);
  };

/**
 * &lt;h3>Primative predicate&lt;/h3>
 * Forms a predicate from a given JavaSCript primative object to act as a typeof check for the input value.
 *
 * Eg. &lt;pre>&lt;code>
 * prim(Function)(() => {}); // true
 * prim(Number)(6); // true
 * &lt;/code>&lt;/pre>
 *
 * @param {object} primative The input primative one of Array, Boolean, Number, Symbol, BigInt, String, Function, Object
 * @return {function} A function of the form &lt;code>{any => boolean}&lt;/code>
 */
const prim = () =>
  function prim(primative) {
    if (primative.name === "Array") return a => Array.isArray(a);

    return a => typeof a === primative.name.toLowerCase();
  };

function createExpressionParser(ctx, expression) {
  if (isFunction(expression)) {
    if (isPrimative(expression)) return prim(ctx);
    return identity;
  }
  if (isRegEx(expression)) return regx(ctx);
  if (isDeepVal(expression)) return deep(ctx);
  return val(ctx);
}

/**
 * &lt;h3>Predicate&lt;/h3>
 * Creates an appropriate predicate based on an input value. This will choose a predicate transformer dynamically based on the type of input.
 *
 * @param {*} input Anything parsable
 * @return {function} A function of the form &lt;code>{any => boolean}&lt;/code>
 */
const pred = ctx =>
  function pred(input) {
    const expParser = createExpressionParser(ctx, input);
    return expParser(input);
  };

const strLen = ctx =>
  function strLen(input) {
    return function strLenFn(a) {
      return typeof a === "string" &amp;&amp; val(ctx)(input)(a.length);
    };
  };

const arrLen = ctx =>
  function arrLen(input) {
    return function arrLenFn(a) {
      return Array.isArray(a) &amp;&amp; val(ctx)(input)(a.length);
    };
  };

const wildcard = () =>
  function wilcard() {
    return true;
  };

const entry = ctx =>
  function entry(name, predicate) {
    return [name, val(ctx)(predicate)];
  };

const Email = () => /^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]+)$/;
const Xc = () => /(?=.*[^a-zA-Z0-9\s]).*/;
const Nc = () => /(?=.*[0-9]).*/;
const Lc = () => /(?=.*[a-z]).*/;
const Uc = () => /(?=.*[A-Z]).*/;
const LUc = () => /(?=.*[a-z])(?=.*[A-Z]).*/;

function passContextToHelpers(ctx, helpers) {
  const acc = {};
  const keys = Object.keys(helpers);
  for (let i = 0; i &lt; keys.length; ++i) {
    const key = keys[i];
    acc[key] = helpers[key](ctx);
  }
  return acc;
}

const _rawHelpers = {
  Email,
  Xc,
  Nc,
  Lc,
  Uc,
  Lc,
  LUc,
  btw,
  btwe,
  lt,
  lte,
  gt,
  gte,
  holds,
  or,
  and,
  not,
  obj,
  val,
  regx,
  entry,
  prim,
  pred,
  deep,
  extant,
  truthy,
  falsey,
  arrArgMatch,
  arrTypeMatch,
  wildcard,
  strLen,
  arrLen
};

module.exports = Object.assign(
  // Main export is the configureHelperFunction
  ctx => passContextToHelpers(ctx, _rawHelpers),
  // Merge on all the helpers configured to default
  passContextToHelpers({}, _rawHelpers),
  // Add getter to get unconfigured helpers
  { getRawHelpers: () => _rawHelpers }
);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#and">and</a></li><li><a href="global.html#arrArgMatch">arrArgMatch</a></li><li><a href="global.html#arrTypeMatch">arrTypeMatch</a></li><li><a href="global.html#btw">btw</a></li><li><a href="global.html#btwe">btwe</a></li><li><a href="global.html#deep">deep</a></li><li><a href="global.html#falsey">falsey</a></li><li><a href="global.html#gt">gt</a></li><li><a href="global.html#gte">gte</a></li><li><a href="global.html#holds">holds</a></li><li><a href="global.html#lt">lt</a></li><li><a href="global.html#lte">lte</a></li><li><a href="global.html#not">not</a></li><li><a href="global.html#or">or</a></li><li><a href="global.html#pred">pred</a></li><li><a href="global.html#prim">prim</a></li><li><a href="global.html#regx">regx</a></li><li><a href="global.html#truthy">truthy</a></li><li><a href="global.html#val">val</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sat Nov 30 2019 01:15:07 GMT+0200 (Eastern European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
